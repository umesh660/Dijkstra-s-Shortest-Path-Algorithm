#!/usr/bin/env python
# coding: utf-8

# ## We have three codes writing by our teams based on three different methods(packages), while the results of which are identical.



# # Pandas Code


# algorithm code
# value of an edge is a property of an edge like time and distance
import pandas as pd

def Dijkstra_calc(graph, start, end='', points=[], undirected=True,
                  pointname='station', edgename='Time', unit='minutes', place=0,
                  totalprint=False, summaryprint=True):
    '''
    :param graph(dict or dataframe): store information of the graph
                                     when it is a dataframe it must record all values of the egdes according to directions and all the points
                                     when it is a dict and the graph is undirected it only needs to contain the information of each edge
                                     when it is a dict and the graph is directed its outer keys
                                     and inner keys must follow the direction of corresponding edges on the graph
                                     with outer keys as the start points and inner keys as destination points of every edge.
    :param start(str): start point
    :param end(str): destination point
    :param points(list): record the names of all points on the graph
                         only take effect when the graph is a dict
                         assign a list containing names of all the points to this parameter
                         when graph is a dict and its outer keys do not contain all the points on the graph
    :param undirected(bool): only take effect when graph is a dict
                             it's True when the graph is undirected or it should be set as False
                             determine whether to transpose the non-null values in the dataframe generated by the dict
                             and assign them to the corresponding location
    :param pointname(str): specify name of points such as station and point
    :param edgename(str): specify name of edges such as Time and Distance
    :param unit(str): specify unit name of edge values
    :param place(int): control demical places of shortest values in summary
    :param totalprint(bool): if it's True, output a table containing total shortest values and routes
    :param summaryprint(bool): if it's True and length of parameter end is lager than 0,
                               print a summary of the shortest value and route from the start point to the destination point
    :return: if length of parameter end is lager than 0
             return a dict containing a table of all the shortest values and routes from the start point and the summary.
             if length of parameter end is equal to 0
             return a dict containing a table of all the shortest values
    '''


    # if parameter graph is a dict, convert it to a dataframe graph_df
    # transpose and assign the not-null values when the network graph is undirected and parameter graph is a dict
    # if parameter graph is a dict and its outer keys don't contain all the points
    # let parameter points be as both the index and the name of columns of graph_df
    # if parameter graph is a dataframe, the algorithm will directly start calculation
    if undirected:
        if type(graph) == dict:
            if len(points) == 0:
                graph_df = pd.DataFrame(None, columns = sorted(list(graph.keys())), index = sorted(list(graph.keys())))

            else:
                graph_df = pd.DataFrame(None, columns=sorted(list(points)), index=sorted(list(points)))

            for i in graph:
                for j in graph[i]:
                    graph_df.loc[j, i] = graph[i][j]

            for i in graph_df:
                for x, y in zip(graph_df[i], graph_df[i].index):
                    if pd.isna(x) == False:
                        graph_df.loc[i, y] = x

        else:
            graph_df = graph

    else:
        if type(graph) == dict:
            graph_df = pd.DataFrame(None, columns=sorted(list(graph.keys())), index=sorted(list(graph.keys())))

            for i in graph:
                for j in graph[i]:
                    graph_df.loc[j, i] = graph[i][j]

        else:
            graph_df = graph

    # define several series to store points, values of egdes and routes, the value can be time, distance and so on
    # series shortest_value is to store shortest values
    shortest_value = pd.Series(None, index = graph_df.index)
    # series shortest_route is to store shortest routes
    shortest_route = pd.Series('',index = graph_df.index)
    # series shortest_inprocess is to store all the points that are directly connected with new start points and the values to the start point
    # its index contains names of points
    shortest_inprocess = pd.Series()
    # shortest_inprocess contains the start point initially
    shortest_inprocess[start] = 0
    # series pointprev is to store the preview point on shortest route of each point
    pointprev = pd.Series()
    # the preview point of the start point is the start point
    pointprev[start] = start


    # do loop when there are still points that have not been labeled with shortest point which means these points are still not in Series shortest_value.
    while len(shortest_value[shortest_value.notnull()]) < len(shortest_value):

        # end loop if the graph is directed and there are points remaining not labeled with shortest
        # but the function can not find more points connected with start point indirectly or directly
        if len(shortest_inprocess) == 0:
            break

        # find the point with minimum value in shortest_inproccess and add it to shortest_value
        shortest_point_local = shortest_inprocess.idxmin()

        shortest_value_local = shortest_inprocess.min()

        shortest_value[shortest_point_local] = shortest_value_local
        # add its route to shortest_route according to the value of its preview point in shortest_route
        shortest_route[shortest_point_local] = shortest_route[pointprev[shortest_point_local]] + '->' + shortest_point_local


        # let the point which has been added into shortest_value just now as new start point
        startnew = shortest_point_local
        # delete the labeled point from shortest_inprocess
        shortest_inprocess = shortest_inprocess.drop(index = startnew)
        # delete the labeled point from the total edge values table graph_df since the shortest point is not considered when calculating the following points
        remaining_points = graph_df.drop(index = shortest_value[shortest_value.notnull()].index)
        # find the values of edges between the new start point and the rest points, the values of not directly connected points are recorded as Nan
        points_data = remaining_points[startnew]
        # extract the points and the values of edges that are connected directly with the new start point
        connected_points = points_data[points_data.notnull()]



        # connected_points.index: name of points, connected_points: value of an egde between a point and the new start point
        # add all the points that are directly connected with the new start point into shortest_inprocess
        # add the preview points of the points above into pointprev respectively
        # if a point is already in shortest_inprocess, then compare its corresponding value to the start point
        # with the value of this edge plus the shortest value of the new start point
        # choose the minimum value
        for x,y in zip(connected_points.index, connected_points):

            if x in shortest_inprocess.index:

                if (y + shortest_value[startnew]) < shortest_inprocess[x]:

                    shortest_inprocess[x] = y + shortest_value[startnew]

                    pointprev[x] = startnew

            else:

                shortest_inprocess[x] = y + shortest_value[startnew]

                pointprev[x] = startnew


    # delete the first two strings of each item of shortest_route since they are redundant '-' and '>'
    shortest_route = shortest_route.str[2:]

    # store the shortest values and routes, extract the value and route according to parameter start and end
    dftotal = pd.concat([round(shortest_value,place), shortest_route], axis=1)

    dftotal.columns = ['{} from {}'.format(edgename, start),'Route from {}'.format(start)]

    print('\n')

    # create a print
    if totalprint:
        print('The total shortest {} and route:\n{}'
              .format(edgename.lower(), dftotal))
        print('\n')

    if len(end)>0:
        Dijkstra_summary = ('Starting {}: {}\n' 
                            'Destination {}: {}\n' 
                            '{}: {:.{}f}{}\n' 
                            'Route: {}'
                            .format(pointname, start, pointname, end, edgename, round(shortest_value[end], place), place,
                                    unit, shortest_route[end]))
        if summaryprint:
            print(Dijkstra_summary)

    if len(end)>0:
        return {'total_table': dftotal, 'summary': Dijkstra_summary}
    else:
        return {'total_table': dftotal}



# network graphs

# smaller test graph
test_graph = {'Kings Cross': {'Euston': 4, 'Paddington': 1},
              'Euston': {'Paddington': 6, 'Waterloo': 8}}

test_stations = ['Kings Cross',
                 'Paddington',
                 'Euston',
                 'Waterloo']

# London metro network graph
network_London_metro = {'Paddington':{'Baker Street': 6, 'Notting Hill Gate': 4},
                        'Notting Hill Gate':{'Bond Street': 7, 'South Kensington': 7},
                        'South Kensington':{'Green Park': 7, 'Victoria': 4},
                        'Victoria':{'Green Park': 2, 'Westminster': 4},
                        'Westminster':{'Green Park': 3, 'Embankment': 2, 'Waterloo': 2},
                        'Waterloo':{'Embankment': 2, 'London Bridge': 3, 'Elephant and Castle': 4},
                        'London Bridge':{'Elephant and Castle': 3, 'Bank': 2},
                        'Blackfriars':{'Embankment': 4, 'Bank': 4},
                        'Piccadilly Circus':{'Green Park': 1, 'Oxford Circus': 2, 'Leicester Square': 2, 'Charing Cross': 2},
                        'Bond Street':{'Baker Street': 2, 'Green Park': 2, 'Oxford Circus': 1},
                        'Oxford Circus':{'Green Park': 2, 'Baker Street': 4, 'Warren Street': 2, 'Tottenham Court Road': 2},
                        'Tottenham Court Road':{'Warren Street': 3, 'Holborn': 2},
                        'Leicester Square':{'Tottenham Court Road': 1, 'Holborn': 2, 'Charing Cross': 2},
                        'Charing Cross':{'Embankment': 1},
                        'Kings Cross':{'Baker Street': 7, 'Warren Street': 3, 'Holborn': 4, 'Moorgate': 6, 'Old Street': 6},
                        'Moorgate':{'Old Street': 1, 'Liverpool Street': 2, 'Bank': 3},
                        'Bank':{'Holborn': 5, 'Liverpool Street': 2, 'Tower Hill': 2},
                        'Tower Hill':{'Liverpool Street': 6, 'Aldgate East': 2},
                        'Aldgate East':{'Liverpool Street': 4}}

stations =['Aldgate East',
           'Baker Street',
           'Bank',
           'Blackfriars',
           'Bond Street',
           'Charing Cross',
           'Elephant and Castle',
           'Embankment',
           'Green Park',
           'Holborn',
           'Kings Cross',
           'Leicester Square',
           'Liverpool Street',
           'London Bridge',
           'Moorgate',
           'Notting Hill Gate',
           'Old Street',
           'Oxford Circus',
           'Paddington',
           'Piccadilly Circus',
           'South Kensington',
           'Tottenham Court Road',
           'Tower Hill',
           'Victoria',
           'Warren Street',
           'Waterloo',
           'Westminster']

# an undirected network graph
graph1 = pd.DataFrame([[0,4,None,None,None,None,8,None,None],
                        [4,0,8,None,None,None,11,None,None],
                        [None,8,0,7,None,2,None,None,4],
                        [None,None,7,0,4,None,None,None,5],
                        [None,None,None,4,0,None,None,None,10],
                        [None,None,2,None,None,0,7,8,None],
                        [8,11,None,None,None,7,0,1,None],
                        [None,None,None,None,None,8,1,0,2],
                        [None,None,4,5,10,None,None,2,0]],
                        columns=['A','B','C','D','E','F','G','H','I'],
                        index=['A','B','C','D','E','F','G','H','I'])

# a directed network graph
graph2 = pd.DataFrame([[0,None,None,7,None],
                       [10,0,None,None,3],
                       [None,1,0,6,9],
                       [None,None,4,0,2],
                       [5,2,None,None,0],],
                       columns = ['A','B','C','D','E'],
                       index = ['A','B','C','D','E'])

# a modified network graph of graph2
graph3 = pd.DataFrame([[0,None,None,None,None],
                       [10,0,None,None,3],
                       [None,1,0,6,9],
                       [None,None,4,0,2],
                       [5,2,None,None,0],],
                       columns = ['A','B','C','D','E'],
                       index = ['A','B','C','D','E'])





# # Networkx  Code



# algorithm code
import networkx as nx

def get_graph(edges):
    
    """
    Input:
    edges: List of tuples (start_station, end_station, travel_time).

    Output:
    graph: A NetworkX Graph with stations as nodes and travel times as edge attributes.
    """
    
    graph = nx.Graph()
    for edge in edges:
        start_station, end_station, travel_time = edge
        graph.add_edge(start_station, end_station, travel_time=travel_time)
    return graph


def find_shortest_path(graph, start, end):
    
    """
    Input:
    graph: A NetworkX Graph.
    start: The starting station.
    end: The destination station.

    Output:
    Prints the shortest path and distance from start to end.
    """
    
    S = {start}
    Y = {station: float('inf') for station in graph.nodes}
    P = {station: [] for station in graph.nodes}

    # Initialize the start station with a distance of 0 and path containing only itself.
    Y[start] = 0
    P[start] = [start]

    # Check if all stations are considered.
    while len(S) < len(graph.nodes):

        min_distance = float('inf')
        next_station = None

        for station in S:
            # Check neighbors of the current station.
            for neighbor in graph.neighbors(station):
                # Process only if the neighbor is not already in S.
                if neighbor not in S:
                    # Calculate distance to this neighbor via the current station.
                    distance = Y[station] + graph[station][neighbor]['travel_time']

                    # If this distance is less than the current minimum,
                    # update the minimum distance, next station, and path.
                    if distance < min_distance:
                        min_distance = distance
                        next_station = neighbor
                        next_path = P[station] + [neighbor]

        # If a next station is found, update S, Y, and P accordingly.
        if next_station:
            S.add(next_station)
            Y[next_station] = min_distance
            P[next_station] = next_path

    # Output logic
    if end in Y and end in P:
        time = Y[end]
        route = " → ".join(P[end])
        print('Starting station:', start)
        print('Destination station:', end)
        print('Time:', time, 'minutes')
        print('Route:', route)
    else:
        print('Route not found.')


# network graphs
edges = [
    ("Waterloo", "Embankment", 2),
    ("Waterloo", "Westminster", 2),
    ("Waterloo", "London Bridge", 3),
    ("Waterloo", "Elephant and Castle", 4),
    ("Embankment", "Charing Cross", 1),
    ("Embankment", "Westminster", 2),
    ("Embankment", "Blackfriars", 4),
    ("Westminster", "Victoria", 4),
    ("Westminster", "Green Park", 3),
    ("Victoria", "South Kensington", 2),
    ("Victoria", "Green Park", 2),
    ("Charing Cross", "Piccadilly Circus", 2),
    ("Charing Cross", "Leicester Square", 2),
    ("Piccadilly Circus", "Oxford Circus", 2),
    ("Piccadilly Circus", "Leicester Square", 2),
    ("Oxford Circus", "Bond Street", 1),
    ("Oxford Circus", "Tottenham Court Road", 2),
    ("Oxford Circus", "Baker Street", 4),
    ("Oxford Circus", "Green Park", 2),
    ("Oxford Circus", "Warren Street", 2),
    ("Bond Street", "Green Park", 2),
    ("Bond Street", "Baker Street", 2),
    ("Bond Street", "Notting Hill Gate", 7),
    ("Green Park", "Piccadilly Circus", 1),
    ("Green Park", "South Kensington", 7),
    ("Elephant and Castle", "London Bridge", 3),
    ("London Bridge", "Bank", 2),
    ("Bank", "Moorgate", 3),
    ("Bank", "Blackfriars", 4),
    ("Bank", "Tower Hill", 2),
    ("Bank", "Holborn", 5),
    ("Bank", "Liverpool Street", 2),
    ("Liverpool Street", "Moorgate", 2),
    ("Liverpool Street", "Tower Hill", 6),
    ("Liverpool Street", "Aldgate East", 4),
    ("Aldgate East", "Tower Hill", 2),
    ("Leicester Square", "Holborm", 2),
    ("Tottenham Court Road", "Holborn", 2),
    ("Kings Cross", "Holborn", 4),
    ("Moorgate", "Old Street", 1),
    ("Moorgate", "Kings Cross", 6),
    ("Old Street", "Kings Cross", 6),
    ("Warren Street", "Kings Cross", 3),
    ("Baker Street", "Kings Cross", 6),
    ("Warren Street", "Tottenham Court Road", 3),
    ("Baker Street", "Paddington", 6),
    ("Paddington", "Notting Hill Gate", 4),
    ("South Kensington", "Notting Hill Gate", 7),
]

london_underground = get_graph(edges)



# # Pure Code

#algorithm code
def Dijkstra(network, station_map, start, destination):
    n = len(network)  # The matrix needs to be constructed with the number of stations,
                      # so this side needs to get the number of stations
    inf = float('inf')  # Representation of infinity
    distance = [inf] * n  # Initialise the values of all the nodes to a large enough value to ensure that during the execution of the algorithm, each node is updated to the shortest practical distance
    visited = [False] * n  # Visited status of each node
    previous = [-1] * n  # Previous node in the path
    path = []  # 'path' is used to save the shortest path.

    # Convert station names to indices
    start_index = station_map[start] - 1
    destination_index = station_map[destination] - 1

    distance[start_index] = 0

    while True:
        # A while loop is used to find the shortest path by first finding the node with the smallest unvisited distance,
        # and then updating the array to mark the node as having been visited.
        # Repeat this until the target station is reached or no more nodes can be reached
        closest_unvisited_node = None
        closest_distance = inf
        for i in range(n):
            if not visited[i] and distance[i] < closest_distance:
                closest_distance = distance[i]
                closest_unvisited_node = i

        if closest_unvisited_node is None:
            # There are no reachable unvisited nodes left
            break

        # Mark the node(station) as visited
        visited[closest_unvisited_node] = True

        # Update the distance between one node and another nodes
        for i in range(n):
            if network[closest_unvisited_node][i] and not visited[i]:
                new_distance = distance[closest_unvisited_node] + network[closest_unvisited_node][i]
                if new_distance < distance[i]:
                    distance[i] = new_distance
                    previous[i] = closest_unvisited_node

        # Stop if the destination has been visited
        if visited[destination_index]:
            break



    # Reconstructing the shortest path
    i = destination_index
    while i >= 0:
        path.insert(0, i)
        i = previous[i]

    # Convert indices back to station names
    path = [list(station_map.keys())[list(station_map.values()).index(i + 1)] for i in path]

    # Calculate total time, if it is unfeasible , set 'unreachable'
    total_time = distance[destination_index] if distance[destination_index] < inf else 'unreachable'

    # Format the path for output
    formatted_path = ' → '.join(path) + '.'
    print("Starting station : {}".format(start))
    print("Destination station : {}".format(destination))
    print("Time : {} minutes".format(total_time))
    print("Route : {}".format(formatted_path))
    
    return total_time,path

# network graphs
# test
# the network is consist of the stations which are shown in the assignment

networkU=[[0,6,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],  # paddington 1
         [6,0,7,0,0,0,0,0,2,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],  # Baker Street 2
         [0,7,0,3,6,6,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],  # Kings Cross 3
         [0,0,3,0,0,0,0,0,0,2,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],  # Warren Street 4
         [0,0,6,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],  # Old Street 5
         [0,0,6,0,1,0,2,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0],  # Moorgate 6
         [0,0,0,0,0,2,0,0,0,0,0,0,4,2,6,0,0,0,0,0,0,0,0,0,0,0,0],  # liverpool Street 7
         [4,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0],  # Notting Hill Gate 8
         [0,2,0,0,0,0,0,7,0,1,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0],  # Bond Street 9
         [0,4,0,2,0,0,0,0,1,0,2,0,0,0,0,2,2,0,0,0,0,0,0,0,0,0,0],  # Oxford Circus 10
         [0,0,0,3,0,0,0,0,0,2,0,2,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0],  # Tottenham Court Road 11
         [0,0,4,0,0,0,0,0,0,0,2,0,0,5,0,0,0,2,0,0,0,0,0,0,0,0,0],  # Holborn 12
         [0,0,0,0,0,0,4,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0],  # Aldgate East 13
         [0,0,0,0,0,3,2,0,0,0,0,5,0,0,2,0,0,0,0,4,0,0,0,0,2,0,0],  # Bank 14
         [0,0,0,0,0,0,6,0,0,0,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0],  # Tower Hill 15
         [0,0,0,0,0,0,0,0,2,2,0,0,0,0,0,0,1,0,0,0,7,2,3,0,0,0,0],  # Green Park 16
         [0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,1,0,2,2,0,0,0,0,0,0,0,0],  # Piccadilly Circus 17
         [0,0,0,0,0,0,0,0,0,0,1,2,0,0,0,0,2,2,2,0,0,0,0,0,0,0,0],  # Leicester Square 18
         [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,0,0,0,0,0,1,0,0,0],  # Charing Cross 19
         [0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,4,0,0,0],  # Blackfriars 20
         [0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,7,0,0,0,0,0,4,0,0,0,0,0],  # South Kensington 21
         [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,4,0,4,0,0,0,0],  # Victoria 22
         [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,4,0,2,0,2,0],  # Westminster 23
         [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,4,0,0,2,0,0,2,0],  # Embankment 24
         [0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,3,3],  # London Bridge 25
         [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,3,0,4],  # Waterloo 26
         [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,4,0],]  # Elephant and Castle 27

station_map = {"Paddington": 1, "Baker Street": 2, "Kings Cross": 3, "Warren Street": 4, "Old Street": 5, "Moorgate": 6,
               "Liverpool Street":7,"Notting Hill Gate":8,"Bond Street":9,"Oxford Circus":10,"Tottenham Court Road":11,"Holborn":12,
               "Aldgate East":13,"Bank":14,"Tower Hill":15,"Green Park":16,"Piccadilly Circus":17,"Leicester Square":18,
               "Charing Cross":19,"Blackfriars":20,"South Kensington":21,"Victoria":22,"Westminster":23,"Embankment":24,
               "London Bridge":25,"Waterloo": 26,"Elephant and Castle":27}





# # Results

# results of Pandas Code
# a test graph
# 4 journeys from Pandas Code
# 3 applications for other graphs

print('\033[1;32m Results of Pandas code:\033[0m\n')

#test
print('\n\ntest on a smaller network:')

Dijkstra_calc(test_graph, 'Waterloo', 'Paddington', points=test_stations)


#journeys
print('\n\njourneys at London metro:')

Dijkstra_calc(network_London_metro,'Waterloo','Paddington', stations)

Dijkstra_calc(network_London_metro,'Victoria','Aldgate East', stations)

Dijkstra_calc(network_London_metro,'Holborn','Elephant and Castle', stations)

Dijkstra_calc(network_London_metro,'Bank','Green Park', stations)


#other graphs
print('\n\napplications for other graphs:')

Dijkstra_calc(graph1, 'A', 'E', pointname='point', edgename='Distance', unit='')

Dijkstra_calc(graph2, 'D', 'B', undirected = False,
              pointname='point', edgename='Distance', unit='')

Dijkstra_calc(graph3, 'D', undirected = False,
              pointname='point', edgename='Distance', unit='', totalprint=True)



# results of Networx Code
# 4 journeys from Networx Code

print('\033[1;32m Results of Networx code:\033[0m\n')

G = london_underground
start_stations = ['Waterloo', 'Victoria', 'Holborn', 'Bank']
destination = ['Paddington', 'Aldgate East', 'Elephant and Castle', 'Green Park']

for s, d in zip(start_stations, destination):
    find_shortest_path(G, s, d)
    print('\n')



# results of Pure Code
# 4 journeys from Pure Code

print('\033[1;32m Results of Pure code:\033[0m\n')

start_node = ['Waterloo', 'Victoria', 'Holborn', 'Bank']
end_nodes = ['Paddington', 'Aldgate East', 'Elephant and Castle', 'Green Park']

for s,e in zip(start_node, end_nodes):
    total_time, path = Dijkstra(networkU, station_map, s, e)
    print('\n')






